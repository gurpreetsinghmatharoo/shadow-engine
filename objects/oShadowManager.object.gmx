<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Customization
//Lighting
lightMode = 0; //Explained in documentation

//Lighting mode 0
lightX[0] = x; //Light x position
lightY[0] = y; //Light y position
dynamicLen = true; //Should the shadow length be dynamic, based on distance?
baseDist = 32; //Distance at which the shadow length is base (shadowLen below)
               //Only used if dynamicLen is true
maxDist = 128; //Max distance for the dynamic length

//Lighting mode 1
shadowDir = -100; //Direction towards which the shadows are casted

//Shadow properties
shadowLen = 1; //Shadow length in comparison to sprite height
shadowColor = make_color_rgb(0, 5, 53);
shadowAlpha = 0.5;

circleSize = 0.6; //Size of the shadow circle (1 = texture width)

//Effects
distFading = true; //Distance fading
baseAlpha = 32; //If distFacing is enabled,
                 //this is the distance beyond which the alpha starts to decrease

//Shadow position
bottomMask = true; //Whether to draw the shadow at the bottom of the mask
                   //If off, it'll be drawn at the center

shadowOffsetX = 0; //Offset to add to the shadow's x position
shadowOffsetY = 0; //Offset to add to the shadow's y position
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INTERNAL
//Scrapped vars
blurDist = 0.8; //How early should the blur start? (1 = texture height)
blurDynamic = false; //Should the blur be dynamic, based on the shadow length?

//MOVED TO SHADER: blurPower = 8; //Blur power, how much blurring to apply?
               //No blur at or below 1

//MOVED TO SHADER: blurAccuracy = 8; //Accuracy of the blur. Higher values make shader slower
               
//Misc
//REMOVED optimize = 1; //Optimization to make the shader compilation faster
                  //You could, of course, lose some quality (minor)

//Surface
surf = -1;

//Shader
uniUvs = shader_get_uniform(shSSWhite, "uvs");
uniDistB = shader_get_uniform(shSSWhite, "distBase");
uniDistC = shader_get_uniform(shSSWhite, "distChecking");
//uniFade = shader_get_uniform(shSSWhite, "fade");

uniTexel = shader_get_uniform(shSSBlur, "texel");
uniAlpha = shader_get_uniform(shSSBlur, "alpha");
//uniBlurPower = shader_get_uniform(shSSBlur, "blurDist");
//uniBlurAcc = shader_get_uniform(shSSBlur, "blurAcc");
//uniOpt = shader_get_uniform(shSSBlur, "opt");

uniTexel2 = shader_get_uniform(shSSWhite, "texel");
uniAlpha2 = shader_get_uniform(shSSWhite, "alpha");
uniBlurPower2 = shader_get_uniform(shSSWhite, "blurDist");
uniBlurAcc2 = shader_get_uniform(shSSWhite, "blurAcc");

//Exceptions
except = ds_list_create();
//ds_list_add(except, oSSCubeCaster);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean up
if (surface_exists(surf)){
    surface_free(surf);
}

ds_list_destroy(except);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Begin
//Surface
if (!surface_exists(surf)){
    surf = surface_create(view_wview, view_hview);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw
//Vars
var cX = view_xview;
var cY = view_yview;

//Surface
surface_set_target(surf);
draw_clear_alpha(0, 0);

//Draw shadows
shader_set(shSSWhite);
//shader_set_uniform_f(uniAlpha2, shadowAlpha);
//shader_set_uniform_f(uniBlurPower2, blurPower);
//shader_set_uniform_f(uniBlurAcc2, blurAccuracy);
//draw_set_blend_mode(bm_add);

with (all){
    var lIn = ds_list_find_index(other.except, object_index)&gt;=0 || 
              ds_list_find_index(other.except, id)&gt;=0 ||
              ds_list_find_index(other.except, object_get_parent(object_index))&gt;=0;
              
    var cubeCaster = object_index==oSSCubeCaster;
              
    //Transfer vars
    var sDir = other.shadowDir;
    var sLen = other.shadowLen;
    
    var lightMode = other.lightMode;
    
    //Draw
    if (sprite_exists(sprite_index) &amp;&amp; !lIn){
        //Get texture
        var tex = sprite_get_texture(sprite_index, image_index);
        var uvs = sprite_get_uvs(sprite_index, image_index);
        
        //Circle position
        var xx = x + (sprite_width/2 - sprite_xoffset) - 1;
        var yy = bbox_bottom - 1;
        
        //y position
        if (!other.bottomMask){
            yy = y - 1;
        }
        
        //Camera offset
        xx -= cX;
        yy -= cY;
        
        xx += other.shadowOffsetX;
        yy += other.shadowOffsetY;
        
        //Shadow info
        var w = (uvs[2]-uvs[0])/texture_get_texel_width(tex);
        var r = (w/2)*other.circleSize;
        var sDist = bbox_bottom - y;
        
        //Draw circle
        if (!cubeCaster){
            //shader_reset();
            //shader_set(shSSAlpha);
            draw_circle_colour(xx, yy, r, -1, 0, 0);
            //shader_reset();
            //shader_set(shSSWhite);
        }
        
        for(var i=0; i&lt;array_length_1d(other.lightX); i++){
            //Position
            var lX = other.lightX[i];
            var lY = other.lightY[i];
            
            //Direction
            if (lightMode == 0){
                sDir = point_direction(x, y, lX, lY)-180;
                sLen = other.shadowLen;
                
                if (other.dynamicLen){
                    var dist = min(other.maxDist, point_distance(x, y, lX, lY));
                    sLen *= dist/other.baseDist;
                }
            }
            
            //Alpha
            var sAlpha = 1;
            if (other.distFading){
                var dist = point_distance(x, y, lX, lY);
                sAlpha = min(1, other.baseAlpha/dist);
                
                //Threshold
                //if (sAlpha &lt; 0.4){
                //    sAlpha = 0;
                //}
            }
        
            //Shadow position
            var sX = xx + lengthdir_x(sDist * sLen, sDir);
            var sY = yy + lengthdir_y(sDist * sLen, sDir);
            
            //Blur distance
            var bDist = other.blurDist;
            
            if (other.blurDynamic){
                bDist /= sLen;
            }
            
            //Normal object
            if (!cubeCaster){
                //Shader
                //shader_set_uniform_f_array(other.uniUvs, uvs);
                //shader_set_uniform_f(other.uniDistC, 0);
                //shader_set_uniform_f(other.uniDistB, bDist);
                //shader_set_uniform_f(other.uniTexel2, texture_get_texel_width(tex),
                //    texture_get_texel_height(tex));
                //shader_set_uniform_f(other.uniFade, other.fadeEnable);
            
                //Sprite
                //shader_set_uniform_f(other.uniDistC, 1);
                draw_sprite_ext(sprite_index, image_index, sX, sY, 1, -sLen, 90 + sDir, -1, sAlpha);
            }
            //Cube caster
            else{
                //Surf
                var cubeSurf = surface_create(view_wview, view_hview);
                
                surface_reset_target();
                surface_set_target(cubeSurf);
                draw_clear_alpha(0, 0);
            
                //Rect
                var x1 = x - cX;
                var y1 = y - cY;
                var x2 = (x + cubeW) - cX+1;
                var y2 = (y + cubeH) - cY+1;
                
                //Shadow
                var sRLen = sLen * cubeZH;
                
                //Shadow rect
                var sX1 = x1 + lengthdir_x(sRLen, sDir);
                var sY1 = y1 + lengthdir_y(sRLen, sDir);
                var sX2 = x2 + lengthdir_x(sRLen, sDir);
                var sY2 = y2 + lengthdir_y(sRLen, sDir);
                
                //Shader
                //shader_reset();
                
                //Draw rects
                draw_set_color(c_black);
                //draw_set_alpha(sAlpha);
                draw_rectangle(x1, y1, x2, y2, 0);
                draw_rectangle(sX1, sY1, sX2, sY2, 0);
                //draw_set_alpha(1);
                draw_set_color(-1);
                
                //Triangles
                //draw_set_blend_mode(bm_add);
                
                draw_primitive_begin(pr_trianglestrip);
                
                /*draw_vertex_colour(sX1, sY1, c_black, 1);
                draw_vertex_colour(sX1, sY2, c_black, 1);
                draw_vertex_colour(x1, y1, c_white, 1);
                
                draw_vertex_colour(sX1, sY2, c_black, 1);
                draw_vertex_colour(x1, y1, c_white, 1);
                draw_vertex_colour(x1, y2, c_white, 1);
                
                draw_vertex_colour(sX1, sY2, c_black, 1);
                draw_vertex_colour(sX2, sY2, c_black, 1);
                draw_vertex_colour(x1, y2, c_white, 1);
                
                draw_vertex_colour(sX2, sY2, c_black, 1);
                draw_vertex_colour(x1, y2, c_white, 1);
                draw_vertex_colour(x2, y2, c_white, 1);
                
                draw_vertex_colour(sX2, sY2, c_black, 1);
                draw_vertex_colour(sX2, sY1, c_black, 1);
                draw_vertex_colour(x2, y2, c_white, 1);
                
                draw_vertex_colour(sX2, sY1, c_black, 1);
                draw_vertex_colour(x2, y2, c_white, 1);
                draw_vertex_colour(x2, y1, c_white, 1);
                
                draw_vertex_colour(sX2, sY1, c_black, 1);
                draw_vertex_colour(x2, y1, c_white, 1);
                draw_vertex_colour(x1, y1, c_white, 1);
                
                draw_vertex_colour(sX1, sY1, c_black, 1);
                draw_vertex_colour(x2, y1, c_white, 1);
                draw_vertex_colour(x1, y1, c_white, 1);*/
                
                draw_vertex_colour(x1, y1, 0, 1);
                draw_vertex_colour(sX1, sY1, 0, 1);
                
                draw_vertex_colour(x1, y2, 0, 1);
                draw_vertex_colour(sX1, sY2, 0, 1);
                
                draw_vertex_colour(x2, y2, 0, 1);
                draw_vertex_colour(sX2, sY2, 0, 1);
                
                draw_vertex_colour(x2, y1, 0, 1);
                draw_vertex_colour(sX2, sY1, 0, 1);
                
                draw_primitive_end();
                
                //draw_set_blend_mode(bm_normal);
                
                //Shader
                //shader_set(shSSWhite);
                
                //Surf
                surface_reset_target();
                surface_set_target(other.surf);
                draw_surface_ext(cubeSurf, 0, 0, 1, 1, 0, -1, sAlpha);
                surface_free(cubeSurf);
            }
            
            //Break
            if (other.lightMode == 1){
                break;
            }
        }
    }
}

shader_reset();
draw_set_blend_mode(bm_normal);

surface_reset_target();

//Final
shader_set(shSSBlur);
var tex = surface_get_texture(surf);
shader_set_uniform_f(uniTexel, texture_get_texel_width(tex),
    texture_get_texel_height(tex));
shader_set_uniform_f(uniAlpha, shadowAlpha);
//shader_set_uniform_f(uniBlurPower, blurPower);
//shader_set_uniform_f(uniBlurAcc, blurAccuracy);
//shader_set_uniform_f(uniOpt, optimize);

draw_surface_ext(surf, cX, cY, 1, 1, 0, shadowColor, 1);

shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
