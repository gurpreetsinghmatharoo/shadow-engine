<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Customization
//Lighting
lightMode = 0; //Explained in documentation

//Lighting mode 0
lightX[0] = undefined; //First light x position
lightY[0] = undefined; //First light y position
dynamicLen = true; //Should the shadow length be dynamic, based on distance?
baseDist = 32; //Distance at which the shadow length is base (shadowLen below)
               //Only used if dynamicLen is true
maxDist = 128; //Max distance for the dynamic length

//Lighting mode 1
shadowDir = -100; //Direction towards which the shadows are casted

//Shadow properties
shadowLen = 1; //Shadow length in comparison to sprite height
shadowColor = make_color_rgb(0, 5, 53);
shadowAlpha = 0.5;

circleSize = 0.8; //Size of the shadow circle (1 = texture width)

//Effects
blurDist = 0.8; //How early should the blur start? (1 = texture height)

distFading = true; //Distance fading
baseAlpha = 32; //If distFacing is enabled,
                 //this is the distance beyond which the alpha starts to decrease

//Shadow properties
maskCenterX = true; //Whether to use the center of the mask (true) or the sprite (false)
bottomMask = true; //Whether to draw the shadow at the bottom of the mask
                   //If off, it'll be drawn at the center

shadowOffsetX = 1; //Offset to add to the shadow's x position
shadowOffsetY = 1; //Offset to add to the shadow's y position
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INTERNAL
//Scrapped vars
blurDynamic = false; //Should the blur be dynamic, based on the shadow length?

shadowRotate = false; //Should a shadow rotate with image_angle?

//MOVED TO SHADER: blurPower = 8; //Blur power, how much blurring to apply?
               //No blur at or below 1

//MOVED TO SHADER: blurAccuracy = 8; //Accuracy of the blur. Higher values make shader slower
               
//Misc
//REMOVED optimize = 1; //Optimization to make the shader compilation faster
                  //You could, of course, lose some quality (minor)

//Surface
surf = -1;

//Shader
uniCube = shader_get_uniform(shSSWhite, "isCube");
uniCubeCenter = shader_get_uniform(shSSWhite, "cubeCenter");

uniUvs = shader_get_uniform(shSSWhite, "uvs");
uniDistB = shader_get_uniform(shSSWhite, "distBase");
uniDistC = shader_get_uniform(shSSWhite, "distChecking");
//uniFade = shader_get_uniform(shSSWhite, "fade");

uniTexel = shader_get_uniform(shSSBlur, "texel");
uniAlpha = shader_get_uniform(shSSBlur, "alpha");
//uniBlurPower = shader_get_uniform(shSSBlur, "blurDist");
//uniBlurAcc = shader_get_uniform(shSSBlur, "blurAcc");
//uniOpt = shader_get_uniform(shSSBlur, "opt");

uniTexel2 = shader_get_uniform(shSSWhite, "texel");
uniAlpha2 = shader_get_uniform(shSSWhite, "alpha");
uniBlurPower2 = shader_get_uniform(shSSWhite, "blurDist");
uniBlurAcc2 = shader_get_uniform(shSSWhite, "blurAcc");

//Exceptions
except = ds_list_create();
//ds_list_add(except, oSSCubeCaster);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean up
if (surface_exists(surf)){
    surface_free(surf);
}

ds_list_destroy(except);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Begin
//Surface
if (!surface_exists(surf)){
    surf = surface_create(view_wview, view_hview);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw
//Vars
var cX = view_xview;
var cY = view_yview;
var cW = view_wview;
var cH = view_hview;

//Surface
surface_set_target(surf);
draw_clear_alpha(0, 0);

//Draw shadows
shader_set(shSSWhite);
//shader_set_uniform_f(uniAlpha2, shadowAlpha);
//shader_set_uniform_f(uniBlurPower2, blurPower);
//shader_set_uniform_f(uniBlurAcc2, blurAccuracy);
draw_set_blend_mode(bm_add);

with (all){
    var lIn = ds_list_find_index(other.except, object_index)&gt;=0 || 
              ds_list_find_index(other.except, id)&gt;=0 ||
              ds_list_find_index(other.except, object_get_parent(object_index))&gt;=0;
              
    var cubeCaster = object_index==oSSCubeCaster;
              
    //Transfer vars
    var sDir = other.shadowDir;
    var sLen = other.shadowLen;
    
    var lightMode = other.lightMode;
    
    //Instance's shadow position
    var iX = (x - sprite_xoffset) + sprite_width/2;
    var iY = y;
    if (other.maskCenterX){
        iX = lerp(bbox_left, bbox_right, 0.5);
    }
    if (other.bottomMask){
        iY = bbox_bottom;
    }
    
    //Distance from center
    var xCenterDist = x - iX;
    
    //Draw
    if (sprite_exists(sprite_index) &amp;&amp; !lIn){
        //Get texture
        var tex = sprite_get_texture(sprite_index, image_index);
        var uvs = sprite_get_uvs(sprite_index, image_index);
        
        //Circle position
        var xx = iX - 1;
        var yy = iY - 1;
        
        //Camera offset
        xx -= cX;
        yy -= cY;
        
        xx += other.shadowOffsetX;
        yy += other.shadowOffsetY;
        
        //Shadow info
        var w = (uvs[2]-uvs[0])/texture_get_texel_width(tex);
        var r = (w/2)*other.circleSize;
        var sDist = (bbox_bottom+1) - y;
        
        //Draw circle
        if (!cubeCaster){
            shader_reset();
            shader_set(shSSAlpha);
            draw_circle_colour(xx, yy, r, -1, 0, 0);
            shader_reset();
            shader_set(shSSWhite);
        }
        
        for(var i=0; i&lt;array_length_1d(other.lightX); i++){
            //Position
            var lX = other.lightX[i];
            var lY = other.lightY[i];
            
            if ((lX==undefined || lY==undefined) &amp;&amp; other.lightMode==0) continue;
            
            //Direction
            if (lightMode == 0){
                sDir = point_direction(iX, iY, lX, lY)-180;
                sLen = other.shadowLen;
                
                if (other.dynamicLen){
                    var dist = min(other.maxDist, point_distance(iX, iY, lX, lY));
                    sLen *= dist/other.baseDist;
                }
            }
            
            //Alpha
            var sAlpha = 1;
            if (other.distFading &amp;&amp; other.lightMode==0){
                var dist = point_distance(iX, iY, lX, lY);
                sAlpha = min(1, other.baseAlpha/dist);
                
                //Threshold
                //if (sAlpha &lt; 0.4){
                //    sAlpha = 0;
                //}
            }
        
            //Shadow position
            var sX = xx + lengthdir_x(sDist * sLen, sDir);
            var sY = yy + lengthdir_y(sDist * sLen, sDir);
            sX += lengthdir_x(xCenterDist, sDir+90);
            sY += lengthdir_y(xCenterDist, sDir+90);
            
            //Blur distance
            var bDist = other.blurDist;
            
            if (other.blurDynamic){
                bDist /= sLen;
            }
            
            //Normal object
            if (!cubeCaster){
                //Rotated
                if (other.shadowRotate){
                    /*/Rotation
                    var p1Dir = point_direction(sprite_xoffset, sprite_yoffset, 0, 0);
                    var p1Dist = point_distance(sprite_xoffset, sprite_yoffset, 0, 0);
                    
                    var p2Dir = point_direction(sprite_xoffset, sprite_yoffset, sprite_width, 0);
                    var p2Dist = point_distance(sprite_xoffset, sprite_yoffset, sprite_width, 0);
                    
                    var p3Dir = point_direction(sprite_xoffset, sprite_yoffset, sprite_width, sprite_height);
                    var p3Dist = point_distance(sprite_xoffset, sprite_yoffset, sprite_width, sprite_height);
                    
                    var p4Dir = point_direction(sprite_xoffset, sprite_yoffset, 0, sprite_height);
                    var p4Dist = point_distance(sprite_xoffset, sprite_yoffset, 0, sprite_height);
                    
                    var x1 = sprite_xoffset + lengthdir_x(p1Dist, p1Dir + image_angle);
                    var y1 = sprite_yoffset + lengthdir_y(p1Dist, p1Dir + image_angle);
                    
                    var x2 = sprite_xoffset + lengthdir_x(p2Dist, p2Dir + image_angle);
                    var y2 = sprite_yoffset + lengthdir_y(p2Dist, p2Dir + image_angle);
                    
                    var x3 = sprite_xoffset + lengthdir_x(p3Dist, p3Dir + image_angle);
                    var y3 = sprite_yoffset + lengthdir_y(p3Dist, p3Dir + image_angle);
                    
                    var x4 = sprite_xoffset + lengthdir_x(p4Dist, p4Dir + image_angle);
                    var y4 = sprite_yoffset + lengthdir_y(p4Dist, p4Dir + image_angle);
                    
                    //Size
                    var minX = min(x1, x2, x3, x4);
                    var maxX = max(x1, x2, x3, x4);
                    var minY = min(y1, y2, y3, y4);
                    var maxY = max(y1, y2, y3, y4);
                    
                    var sprWNew = maxX - minX;
                    var sprHNew = maxY - minY;
                    
                    var diffW = (sprWNew - sprite_width)/2;
                    var diffH = (sprHNew = sprite_height)/2;
                
                    //Surface
                    var sprSurf = surface_create(sprWNew, sprHNew);
                    
                    surface_set_target(sprSurf);
                    shader_reset();
                    
                    draw_sprite_ext(sprite_index, image_index, diffW + sprite_xoffset, diffH + sprite_yoffset,
                        image_xscale, image_yscale, image_angle, -1, 1);
                    
                    surface_reset_target();
                    shader_set(shSSWhite);
                    
                    //Texture
                    var surfTex = surface_get_texture(sprSurf);
                    var uvs; uvs[0] = 0; uvs[1] = 0; uvs[2] = 1; uvs[3] = 1;
                    
                    //Draw
                    shader_set_uniform_f(other.uniCube, 0);
                    shader_set_uniform_f_array(other.uniUvs, uvs);
                    shader_set_uniform_f(other.uniDistB, bDist);
                    shader_set_uniform_f(other.uniTexel2, texture_get_texel_width(surfTex),
                        texture_get_texel_height(surfTex));
                
                    //Surface
                    var oDir = point_direction(sprite_xoffset, sprite_yoffset, 0, 0);
                    var oDist = point_distance(sprite_xoffset, sprite_yoffset, 0, 0);
                    
                    var sDrawDir = 90 + sDir;
                    
                    //sX += lengthdir_x(oDist, oDir + sDrawDir);
                    //sY += lengthdir_y(oDist, oDir + sDrawDir);
                    
                    draw_surface_ext(sprSurf, sX, sY, 1, -sLen, sDrawDir, -1, sAlpha);
                    
                    shader_reset();
                    draw_circle_colour(sX, sY, 4, 1, 1, 0);
                    shader_set(shSSWhite);
                    
                    //Free
                    surface_free(sprSurf);*/
                }
                //Unrotated
                else{
                    //Shader
                    shader_set_uniform_f(other.uniCube, 0);
                    shader_set_uniform_f_array(other.uniUvs, uvs);
                    shader_set_uniform_f(other.uniDistB, bDist);
                    shader_set_uniform_f(other.uniTexel2, texture_get_texel_width(tex),
                        texture_get_texel_height(tex));
                    //shader_set_uniform_f(other.uniFade, other.fadeEnable);
                
                    //Sprite
                    //shader_set_uniform_f(other.uniDistC, 1);
                    draw_sprite_ext(sprite_index, image_index, sX, sY, image_xscale, -sLen*image_yscale, (90 + sDir), -1, sAlpha);
                }
            }
            //Cube caster
            else{
                //Surf
                //var cubeSurf = surface_create(cW, cH);
                
                //Reset
                surface_reset_target();
                shader_reset();
                
                //Cube surf
                surface_set_target(cubeSurf);
                draw_clear_alpha(0, 0);
            
                //Rect
                var x1 = x - cX;
                var y1 = y - cY;
                var x2 = (x + cubeW) - cX+1;
                var y2 = (y + cubeH) - cY+1;
                
                //Shadow
                var sRLen = sLen * cubeZH;
                
                //Shadow rect
                var sX1 = x1 + lengthdir_x(sRLen, sDir);
                var sY1 = y1 + lengthdir_y(sRLen, sDir);
                var sX2 = x2 + lengthdir_x(sRLen, sDir);
                var sY2 = y2 + lengthdir_y(sRLen, sDir);
                
                //Shader
                //shader_reset();
                
                //Draw rects
                //draw_set_color(c_black);
                draw_rectangle(x1, y1, x2, y2, 0);
                //draw_set_color(-1);
                draw_rectangle(sX1, sY1, sX2, sY2, 0);
                
                //Triangles
                //draw_set_blend_mode(bm_add);
                
                draw_primitive_begin(pr_trianglestrip);
                
                draw_vertex_colour(x1, y1, -1, 1);
                draw_vertex_colour(sX1, sY1, -1, 1);
                
                draw_vertex_colour(x1, y2, -1, 1);
                draw_vertex_colour(sX1, sY2, -1, 1);
                
                draw_vertex_colour(x2, y2, -1, 1);
                draw_vertex_colour(sX2, sY2, -1, 1);
                
                draw_vertex_colour(x2, y1, -1, 1);
                draw_vertex_colour(sX2, sY1, -1, 1);
                
                draw_primitive_end();
                
                //draw_set_blend_mode(bm_normal);
                
                //Shader
                //shader_set(shSSWhite);
                
                //Reset
                surface_reset_target();
                
                //Shader
                shader_set(shSSWhite);
                shader_set_uniform_f(other.uniCube, 1);
                shader_set_uniform_f(other.uniCubeCenter, (x1+cubeW/2)/cW, (y1+cubeH/2)/cH);
                
                //Try
                var cubeTex = surface_get_texture(cubeSurf);
                shader_set_uniform_f(other.uniUvs, 0, 0, 1, 1);
                shader_set_uniform_f(other.uniDistB, bDist/4);
                shader_set_uniform_f(other.uniTexel2, texture_get_texel_width(cubeTex),
                    texture_get_texel_height(cubeTex));
                
                surface_set_target(other.surf);
                draw_surface_ext(cubeSurf, 0, 0, 1, 1, 0, -1, sAlpha);
                //surface_free(cubeSurf);
            }
            
            //Break
            if (other.lightMode == 1){
                break;
            }
        }
    }
}

shader_reset();
draw_set_blend_mode(bm_normal);

surface_reset_target();

//Final
shader_set(shSSBlur);
//var tex = surface_get_texture(surf);
//shader_set_uniform_f(uniTexel, texture_get_texel_width(tex),
//    texture_get_texel_height(tex));
//shader_set_uniform_f(uniAlpha, shadowAlpha);
//shader_set_uniform_f(uniBlurPower, blurPower);
//shader_set_uniform_f(uniBlurAcc, blurAccuracy);
//shader_set_uniform_f(uniOpt, optimize);

draw_surface_ext(surf, cX, cY, 1, 1, 0, shadowColor, shadowAlpha);

shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
